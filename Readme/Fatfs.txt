/******************************************************************************
	*文件名：Fatfs开发文档
	*作  者：王峰
	*时  间：2021.02.12
	*说  明：Fatfs文件系统移植和开发相关说明
*******************************************************************************/

1、Fatfs文件作用说明：
	(1)diskio.h：
	Fatfs文件系统底层配置头文件，包含驱动函数声明。
	
	(2)diskio.c
	Fatfs文件系统底层配置源文件，包含驱动函数定义实现。
	
	(3)ff.h：
	Fatfs文件系统中间件头文件，包含文件系统中间件功能函数声明。
	
	(4)ff.c：
	Fatfs文件系统中间件源文件，包含文件系统中间件功能函数定义实现。
	
	(5)ffunicode.c
	Fatfs文件系统支持编码选项配置相关功能函数定义实现。
	
	(6)ffconf.h：
	Fatfs文件系统中间件相关配置文件（可对文件系统进行裁剪）。
	（2021.02.12）
	
2、关于数据类型定义的问题：
	在之前的旧版本中有一个专门的头文件包含了文件系统所用的数据类型定义，而在最新版本中没有这个头文件，
	相关数据类型的定义在ff.h头文件中定义。
	（2021.02.12）
	
3、支持编码选项：
	在之前旧版本中src文件夹中有一个option文件夹，里面有各种编码的源文件，需要使用那种编码就把相应的
	源文件包含到工程中，而在最新版本中只有一个ffunicode.c源文件，里面包含了各种编码实现，想要支持那种
	编码，只需使能相应的宏定义（在ffconf.h）即可。 
	（2021.02.12）
	
4、diskio.c文件修改说明：
	(1)定义SD卡和SPI FLASH芯片的设备号宏（目前暂时使用到这两种存储介质）
	(2)get_fattime()函数的说明，默认配置是只有声明，没有定义，所以会编译会报错，需要自己在diskio.c中实现get_fattime()函数。
	(3)disk_initialize()、disk_status()、disk_read()、disk_write()等函数实现就是调用相应存储设备的底层驱动即可。
	(4)disk_ioctl()函数的作用是获取存储设备的物理特性，从而让中间层调用实现控制。其中物理参数返回方式值得思考一下，它并不是通过返回值
	来返回物理参数，而是通过函数参数（void*）buff来返回，这里的void*用的十分巧妙，由于void*的特性。是的buff可以接收任何数据类型
	的数据。
	(2021.02.17)
	
5、关于diskio.c中状态返回值的说明，通过清除不同的标志位来反映不同的状态。
	（2021.02.12）
	
6、ffconf.h文件的修改说明：
	宏定义FF_MAX_SS（默认值为512）作用是定义存储介质一个扇区最大字节数，W25QXX芯片中一个扇区为4096字节，所以要修改为4096。
	宏定义FF_VOLUMES（默认值为1）支持设备的数量，目前使用到存储介质有SD卡和SPI FLASH， 所以修改为2。
	宏定义FF_CODE_PAGE修改为936支持简体中文。
	宏定义FF_USE_LFN（默认值为0）修改为1，使能LFN(长文件名)存储在静态工作区（全局区）。
	宏定义FF_FS_LOCK（默认值为0）修改为3，支持同时打开3个文件，为0时只能打开一个文件（在只读状态下FF_FS_LOCK必须为0）。
	宏定义FF_USE_MKFS（默认值为0）修改为1，使能FATFS格式化。
	（2021.02.17）
	
7、f_mount()函数使用说明：
	参数说明：
	FATFS *fs
    参数为指向文件系统句柄的指针时挂载文件系统 . 参数为Null pointer(空指针)时取消挂载文件系统.
    const TCHAR*path
    参数为 "" （空字符串）时意味着默认设备，参数为 "NUM:" 时设备为NUM对应的设备。
	BYTE  opt
	参数为0时稍后挂载，参数为1时立即挂载。
	
	FATFS *fs文件句柄不需要初始化，只需定义一个文件系统句柄作为参数传入，f_mount()函数会通过diskio.c中底层函数获取存储设备的
	特性，进行相应的初始化。
	（2021.02.17）
	
8、f_mkfs()函数使用说明：
	参数说明：
	const TCHAR* path      
	参数为 "" （空字符串）时意味着默认设备，参数为 "NUM:" 时设备为NUM对应的设备。
	const MKFS_PARM* opt
	MKFS_PARM为格式化参数结构体（详细信息见ff.h文件），参数为Null pointer(空指针)时，使用默认格式。
	void* work
	work 工作数据缓冲区，一般为一个扇区的大小（W25QXX芯片为4096字节）。
	UINT len
	工作数据缓冲区的长度 ，通过sizeof(work)获取。
	（2021.02.17）
	
9、f_open()函数中文件路径说明：格式为 "DEV_NUM: 文件名"，注意一定不能少了"DEV_NUM:"(相当于电脑的盘名)。（2021.02.17）

10、f_open()打开文件后进行操作，操作结束后一定要使用f_close()关闭文件，否则对文件的操作不会保存。（2021.02.18）

11、关于无法对SD卡进行格式化的问题说明：
	返回错误信息为：14 ：f_mkfs()被某些问题中止了
	猜想：SD卡的读写操作使用到了DMA，可能被DMA中断干扰了（但野火程序为什么可以？），具体原因后期分析。
	解决办法：利用电脑对SD卡进行文件系统（FAT32）格式化，经检验格式化后能够成功挂载文件系统进行读写操作。
	（2021.02.18）
	
12、思考一下word文件、excel文件等如何操作？（2021.02.18）
	
13、内存对齐问题说明：
	SD卡的读写操作都是以4个字节进行对齐操作的，如果说disk_read()或disk_write()传入的缓冲区buff的地址没有对齐（即不能被4
	整除），则无法实现正常的文件读写，所以需要使用内存对齐的缓冲区。因为传入的buff是不可控制的，我们无法保证每次都是内存
	对齐，所以我们要在读写操作前使用 __align(4)来定义一个以4个字节地址对齐的临时缓冲区tembuff，再通过tempbuff对SD卡进行
	读写操作，如果是读操作则将tempbuff的数据拷贝到buff中；如果是写操作，则将buff中的数据拷贝到tempbuff中写入SD卡。
	（2021.02.18）

13、时间戳的获取，后期加入RTC在做实现。（2021.02.18）

14、通过f_getfree()函数获取SD卡剩余空间，以及总容量。实验得到SD卡总容量为3.74GB,可用容量为3.74GB与实际情况相符合。
	通过这个实验我发现标称4GB的卡实际容量只有3.74GB并不是系统占用了0.26GB(实际上文件系统只占用了20kb左右的空间)，可以认为
	0.26GB是误差（或者说4GB是四舍五入的结果）。
	(2021.02.18)
	
15、如果文件系统中的功能函数不知道如何使用，可以查看使用手册中Example.(2021.02.18)	
	
16、#define FF_CODE_PAGE	936   宏定义设置为936可以支持中文，但会占用很大内存，能不使用就尽量不使用。
	